[{"path":"/2025/11/12/什么时候应该抛出异常，什么时候捕获异常/","content":"异常相当于一种提示，如果我们抛出异常，就相当于告诉上层方法，我抛出了一个异常，我处理不了这个异常，交给你来处理。而对于上层方法来说，它也需要决定自己能不能处理这个异常，是否需要交给它的上层。 所以我们在写一个方法时，我们需要考虑的就是，本方法能否合理"},{"path":"/2025/11/12/Java中的异常体系/","content":"Java中的所有异常都来自顶级父类Throwable。 Throwable中有两个子类Exception和Error。 Error表示很严重的错误，比如java.lang.StackOverFlowError和java.lang.OutOfMemoryError，通常这些错误出现，仅仅想考自己是解决不了的，可能是虚拟机、硬盘、操作系统层面出现的问题，所以通常也不建议在代码中捕获这些Error，因为捕获没意义，程序运行不了。 Exception表示异常，当程序出现Exception时，通常可以自己解决，比如NullPointerException、illegalAccesssException等，我们可以捕获异常来进行修改代码处理掉。 异常包括运行时异常和非运行时异常。运行时异常通常不能通过编译器检查出来，比如除以0等等操作，程序应该从逻辑方面考虑错误异常。非运行时异常，通常可以通过编译器检测出来的异常，不检查出来不能编译成功，所以必须处理，比如：io异常，sql异常，用户自定义异常等。"},{"path":"/2025/11/11/什么是字节码，采用字节码的好处是什么/","content":"编译器（javac）将Javv源文件（*.java）文件编译成为字节码文件（*.class），可以做到一次编译随时运行，windows上编译好的class文件，可以直接在linux上运行，通过这种方式可以做到跨平台，不过java的跨平台有一个前提条件，就是不同操作系统上安装的JDK或者JRE是不一样的，虽然字节码是通用的，但是需要把字节码解释成各个操作系统的机器码是需要不同版本的编译器的，所以针对各个操作系统需要用各自的JDK或者JRE。 采用字节码的好处，一方面可以实现跨平台，另一方面也提高代码的执行能力，编译器在编译源代码做出了些许优化。"},{"path":"/2025/11/11/CopyOnWriteArrayList的底层原理是怎样的/","content":"1.首先CopyOnWriteArrayList的内部也是通过数组实现的，在向CopyOnWriteArratList添加元素时，会复制一个新数组，这个写操作进程写操作在新数组上进行，另一个读进程的读操作还是在原数组上进行。 2.写操作是加锁的，防止出现并发写入时的数据丢失问题。 3.写操作完成后会将原数组指向新数组。 4.CopyOnWriteArrayList运行在读时候写入数据，大大提高了读性能，适合读多写少的应用场景，但是CopyOnWriteArrayList会比较占据内存，也可能读到的不是最新数据，不适合对于实时性要求高的场景。"},{"path":"/2025/11/11/HashMap的扩容机制原原理/","content":"1.7版本 1.先将老数组的大小记录，并创建一个新数组的大小为老数组的两倍的数组。 2.取每个元素的key，并基于新数组长度，利用哈希算法计算出每个元素在新数组中的下标。 3.将元素都添加到新数组中去。 4.所有元素添加完后，将新数组赋值给HashMap对象的table属性。 1.8版本 1.先将老数组的大小记录，并创建一个新数组的大小为老数组的两倍的数组。 2.遍历老数组中每个位置上的链表和红黑树。 3.如果是链表，则直接将链表中的每个元素重新计算下标，并添加到新数组中去。 4.如果是红黑树，则先遍历红黑树，先计算出红黑树中每个元素对应到新数组中的下标位置。 ​\ta.统计每个下标位置的元素个数。 ​\tb.如果该位置元素超过了8，则生成一个新的红黑树，并将根节点添加到新数组对应的位置。 ​\tc.如果该位置的元素个数没有超过8，那么则生成一个链表，并将链表的头结点添加到新数组对应的位置。 5.所有元素转移完之后，将新数组赋值给HashMap对象的table属性。"},{"path":"/2025/11/11/深拷贝和浅拷贝/","content":"1.浅拷贝只是将基本数据类型的值和实例对象的引用地址进行拷贝，是指针指向同一个对象 2.深拷贝不但将基本数据类型的值和实例对象的引用地址进行拷贝，而且还创建一个新的对象不同于浅拷贝只是指向，而是两个不同的对象，但是基本数据类型的值和实例对象的引用地址一样。"},{"path":"/2025/11/10/说一下HashMap的Put方法/","content":"1.根据Key通过哈希算法与与运算来计算数组下标 2.如果数组下标元素为空，则将key和value封装为Entry对象（1.7）或者Node对象（1.8），并放入该位置。 3.如果元素下标位置不为空，则分情况讨论 ​\ta.如果是JDK1.7，先判断是否需要扩容，如果不用扩容则生成Entry对象，并用头插法添加到当前位置的链表中。 ​\tb.如果是JDK1.8，则先会判断Node类型，是链表类型还是红黑树类型 ​ i.如果是红黑树,则将key和value封装为红黑树节点并添加到红黑树中去，在这个过程中会判断红黑树是否存在当前key，如果存在则更新value ​ ii.如果此时位置上的节点对象是链表，则将key和value封装为链表节点Node并且尾插法添加到链表中，因为是尾插法，所以需要遍历链表，如果大于8个，则转变成红黑树 ​ iii.将key和value封装的Node插入到链表或者红黑树后，在判断是否需要进行扩容，如果需要就先扩容，不需要就结束PUT方法"},{"path":"/2025/11/10/Jdk 1.7到Jdk 1.8中HashMap有什么区别/","content":"1.1.7中使用的是数组加链表的形式，而1.8是数组、链表加红黑树。加入红黑树的目的是使得HashMap插入和查询的效率增加，把长链表改造成红黑树结构会方便插入和查询。 2.1.7用的头插法（比尾插法快一些），1.8用的尾插法。因为1.7和1.8插入key和value时需要判断链表元素个数，但当链表个数为8时需要将它变成红黑树以避免链表过长，所以使用尾插法。 3.1.7中Hash算法比较复杂，存在右移和异或运算，1.8中进行优化，因为复杂的Hash算法目的是提高散列性，来提供HashMap的整体效率，而1.8使用了红黑树来简化Hash算法的复杂性，节省CPU资源。 带头结点方式实现头插法（顾名思义就是插在头部）： 不带头结点方式实现头插法 带头结点方式实现尾插法和不带头结点方式实现尾插法类似，只是少个头结点"},{"path":"/2025/11/10/ArrayList和LinkedList的区别/","content":"1.首先，ArrayList底层是基于数组实现的，LinkedList是基于链表实现的。 2.由于底层数据结构不同，ArrayList更适合随机查找，LinkedList更适合增加和删除。 3.两者都实现了List接口，但LinkedList还实现了Deque(双端队列)，所以可以当做队列使用。"},{"path":"/2025/11/10/List和Set的区别/","content":"List:有序，按对象进入的顺序保存对象，可重复，允许多个Null对象，可以使用Iterator迭代器遍历，还可以用get(index)的方法获index下标的值。 Set:无序，不可以重复，最多允许一个Null对象，取元素只能用Iterator迭代器从前往后迭代所有元素，不能随机查找。"},{"path":"/2025/11/10/重载和重写方法的区别/","content":"重载：发生在同一个类中，方法名必须相同，参数类型可以不同，参数个数不同，顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 重写：发生在子类中，方法名、参数列表必须相同，返回值范围和抛出异常范围小于等于父类、访问修饰符范围应该大于父类。父类的访问修饰符为private则不能重写该方法。 pubilc int add (int a,String b)pubilc String add (int a,String b)//编译报错,不是重载方法，要改成重载，可以改参数数量和类型不一样即可"},{"path":"/2025/11/10/equals和等于号的区别/","content":"：如果是基本数据类型比较的是数值，如果是引用类型比较的是引用地址。 equals:先比较引用类型，再比较值。如果是一个类对象，只比较引用地址。 下面是string equals的例子："},{"path":"/2025/11/03/图片如何加载到Typora和远端/","content":"图片如何加载到Typora和远端配置Typora打开Typora的偏好设置，按下图的选项方式进行选择和勾选： 复制图片将图片复制到G:\\blog\\source\\images中： 选择复制图像到Typora中 保存Typora。 启动Hexohexo clean hexo g hexo d 等待图片上传到GitHub中： 启动上图路径2339543119.github.io.git 成功上传图片成功。"},{"path":"/2025/10/28/学习关于如何搭建你的第一个静态博客/","content":"学习关于如何搭建你的第一个静态博客安装安装 Git安装 Node安装 hexocmd 查看以下代码： node -vnpm -v 如果弹出版本号，则安装成功。 npm install -g cnpm --registry=https://registry.npm.taobao.org 这里报了个错，原因 淘宝镜像已经停服 迁移了 淘宝 NPM 镜像已经从 https://registry.npm.taobao.org 迁移到 https://registry.npmmirror.com cmd 查看以下代码： cnmp -v 如果弹出信息，则安装成功。 安装 hexo 框架： cnpm install -g hexo-cli 打开自己的第一个 blog新建文件夹 blog 在 blog 目录下进入 cmd（在地址栏按回车）： 初始化 hexo: hexo init 打开 Hello world 博客： hexo s 在网页端进入 localhost: 4000 可以看到 hello world 博客页面 创建第二篇博客，地址位于 source__posts, 在里面创建第二篇 md 文件，可以写入一些文字。 再来打开 cmd，在blog 目录下输入: hexo cleanhexo ghexo s 可以看到你的内容。 将 blog 部署到 GitHub 上登录 GitHub注册一个 GitHub 账号后登录你的 GitHub 账号。 创建 blog 仓库用户署名必须要是你的用户名加上.github.io。 如：23332.github.io 描述：你的 hexo 博客 点击创建。 下载插件并配置npm install hexo-deployer-git --save 打开_config.yml 文件： 配置与上面一样，需要改 repo 为下图 HTTPS 中的链接： 部署到远端在 cmd 中输入启动部署到 GitHub 上： hexo d 启动时要求你的 GitHub 账号密码，当你输入账号密码，你会发现根本登不上去。原因是 2021 年 Git 已经不在支持账号密码登录 GitHub，只能用 token 或者 SSH key 登录。 token 方法：找到 settings- developer settings 找到 Token(classic)并创建 Token 创建 Token 的过程中必须勾选你需要的权限，不然创建了没用（之前犯的错） 记得复制保存你的密钥，只会出现一次： 最后，在 cmd 中输入启动部署到 GitHub 上： hexo d 将密钥复制到 token 处，即可登录成功。 SSH key 方法：[最大同*交流网站变天了？Github 不再支持密码验证的解决方案_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV18v411w7WL/?spm_id_from 333.337.search-card.all.clickvd_source b3a6fe7cb17ffe9e7aff6020f78014df) 通过这个链接即可了解。 出现以下图像为部署成功： 注意现在访问 2339543119.github.io 会出现 404 的情况，应该进行如下修改： 进入 settings 找到 pages 一般第一次创建都为 None, 应该改为 master 或者 main，你看你的项目是什么，我的是 master(与_config.yml 文件和 code 中分支保持一致)。 访问你的远端 blog在地址栏输入你的链接，我的是 2339543119.github.io，进入以下页面： 即为部署成功，快去试试吧。 更改你 blog 的主题进入 cmd，下载主题： git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 找到 blogthemes，把主题名称改为 yilia。 之后再打开_config.yml 文件，修改 theme，保存： 再来打开 cmd，在blog 目录下输入: hexo clean hexo g hexo d 启动成功后，等待几分钟后，主题更改在 2339543119.github.io 页面。"}]